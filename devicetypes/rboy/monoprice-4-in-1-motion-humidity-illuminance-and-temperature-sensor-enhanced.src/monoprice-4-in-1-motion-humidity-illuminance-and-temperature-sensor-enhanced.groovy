/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "02.00.00"
}

/**
 * Monoprice Enhanced 4 in 1 Motion, Humidity, Illuminance and Temperature Sensor (15902)
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2020-10-19 - (v02.00.00) New ST app custom UI
 * 2020-02-06 - (v01.00.09) Update device health
 * 2020-01-20 - (v01.00.08) Fix for broken ST Android Classic app 2.18
 * 2019-11-05 - (v01.00.07) Update device health check protocol
 * 2018-08-23 - (v01.00.06) Don't show decimal for Humidity in Android devices
 * 2018-08-05 - (v01.00.05) Added Health Check capability
 * 2018-08-02 - (v01.00.04) Added basic support for new ST app
 * 2018-01-31 - (v01.00.03) Updated layout to show all sensors on a single screen and temperature offset is now in decimal points
 * 2018-01-12 - (v01.00.02) Update for security descriptors
 * 2017-10-18 - (v01.00.01) Update tile layout with ST mobile app release 2.8.0
 * 2017-07-14 - (v01.00.00) Initial release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */

preferences {
    input title: "", description: "Monoprice Enhanced 4 in 1 Sensor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "PUSH THE BUTTON IN THE TINY HOLE AFTER CONFIGURING THESE OPTIONS FOR THEM TO TAKE EFFECT IMMEDIATELY.", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "Select the Sensor to show on the 'Things' page", displayDuringSetup: true, type: "paragraph", element: "paragraph"
    input "displaySensor", "enum", title: "Primary Sensor", displayDuringSetup: true, options: ["Motion", "Temperature", "Humidity", "Light"]
	input title: "", description: "Inactive timeout is the number of minutes since the last motion was detected after which the sensor will report no motion (1 to 255). Leave it blank to use the default inactivity timeout (3 minutes).", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "noMotionTimeout", "number", title: "Inactive timeout (minutes)", displayDuringSetup: false, range: "1..255"
	input title: "", description: "The temperature sensitivity threshold represents how much the temperature levels should change before reporting it. The threshold can vary from 0.1° (very sensitive) to 5° (least sensitive) (default is 1.0)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "tempSensitivity", "decimal", title: "Temperature Sensitivity", displayDuringSetup: false, range: "0.1..5.0"
	input title: "", description: "Temperature correction offset is a +ve or -ve number to correct the temperature reported by the sensor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "tempOffset", "decimal", title: "Temperature correction offset", displayDuringSetup: false, range: "*..*"
	input title: "", description: "Set the motion detection sensitivity level. 1 is MOST sensitive and 7 is LEAST sensitive (default is 4)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "pirSensitivity", "number", title: "Motion Sensitivity", displayDuringSetup: false, range: "1..7"
	input title: "", description: "The light sensitivity threshold represents what % the light levels should change before reporting it. The threshold can vary from 5% (very sensitive) to 50% (least sensitive) (default is 10%)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "luxSensitivity", "number", title: "Light Sensitivity", displayDuringSetup: false, range: "5..50" // Minimum is 5 even though documentation says 1
	input title: "", description: "Choose the metric for reporting light levels (default is Lux)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "luxMetric", "enum", title: "Light Reporting Metric", defaultValue: "lux", displayDuringSetup: false, options: ["lux", "%"], required: true
	input title: "", description: "The humidity sensitivity threshold represents what % the humidity levels should change before reporting it. The threshold can vary from 1% (very sensitive) to 50% (least sensitive) (default is 10%)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "humiditySensitivity", "number", title: "Humidity Sensitivity", displayDuringSetup: false, range: "1..50"
	input title: "", description: "Humidity correction offset is a +ve or -ve number to correct the humidity reported by the sensor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "humidityOffset", "number", title: "Humidity correction offset", displayDuringSetup: false, range: "*..*"
	input title: "", description: "The LED can work in 3 modes:\n(LED Off) Mode 1 the LED is Off\n(Pulsing) Mode 2 the LED Breathes for a temperature change and Flashes for motion detection (NOTE: This reduces battery life)\n(Quick Flash) Mode 3 the LED flashes for both temperature and motion", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "ledConfig", "enum", title: "LED Notifications", displayDuringSetup: false, options: ["1":"LED Off", "2":"Breathing", "3":"Quick Flash"]
	input title: "", description: "If you want to force a manual poll of the temperature/motion/battery status, enter the polling interval in seconds in increments of 600 seconds (minimum 600, maximum 604800, in intervals of 600 seconds). Leave it blank to use the default value\nNOTE: Polling will reduce battery life", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "manualPollInterval", "number", title: "Manual Poll Interval (seconds)", displayDuringSetup: false, range: "600..604800"
}

metadata {
    definition (name:"Monoprice 4 in 1 Motion, Humidity, Illuminance and Temperature Sensor (Enhanced)", namespace:"rboy", author: "RBoy Apps", ocfDeviceType: "x.com.st.d.sensor.motion", mnmn: "SmartThingsCommunity", vid:"c0d950cc-0e47-333d-b6cf-912b5e79657f") {
		capability "Configuration"
        capability "Sensor"
        capability "Motion Sensor"
        capability "Temperature Measurement"
		capability "Relative Humidity Measurement"
		capability "Illuminance Measurement"
        capability "Battery"
        capability "Tamper Alert"
        capability "Health Check"
        capability "rboyapps.multiSensorDisplay"
        capability "rboyapps.versioning"
        
        ///attribute "codeVersion", "string"
        ///attribute "dhName", "string"
        ///attribute "dashboardDisplay", "string"

        fingerprint deviceId:"0x0701", inClusters: "0x5E,0x86,0x72,0x5A,0x85,0x59,0x73,0x80,0x71,0x31,0x70,0x84,0x7A,0x98", manufacturer: "Monoprice", model: "15902"
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0701", cc:"5E,86,72,5A,85,59,73,80,71,31,70,84,7A,98", mfr:"0109", prod:"2021", model:"2101", deviceJoinName:"Monoprice 4 in 1 Sensor (15902)"
        fingerprint type:"0701", cc:"5E,98", sec:"86,72,5A,85,59,73,80,71,31,70,84,7A", mfr:"0109", prod:"2021", model:"2101", deviceJoinName:"Monoprice 4 in 1 Sensor (15902)"
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4, canChangeIcon: true) {
            tileAttribute ("device.motion", key: "PRIMARY_CONTROL") {
                attributeState "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
                attributeState "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
            }
            //tileAttribute ("device.temperature", key: "SECONDARY_CONTROL") {
			//	attributeState "temperature", label:'${currentValue}°'
            //}
        }
		valueTile("temperature", "device.temperature", width: 2, height: 2) {
			state("temperature", label:'${currentValue}°',
                  backgroundColors:[
                      // Celsius
                      [value: 0, color: "#153591"],
                      [value: 7, color: "#1e9cbb"],
                      [value: 15, color: "#90d2a7"],
                      [value: 23, color: "#44b621"],
                      [value: 28, color: "#f1d801"],
                      [value: 35, color: "#d04e00"],
                      [value: 37, color: "#bc2323"],
                      // Fahrenheit
                      [value: 40, color: "#153591"],
                      [value: 44, color: "#1e9cbb"],
                      [value: 59, color: "#90d2a7"],
                      [value: 74, color: "#44b621"],
                      [value: 84, color: "#f1d801"],
                      [value: 95, color: "#d04e00"],
                      [value: 96, color: "#bc2323"]
                  ]
			)
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "https://www.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        valueTile("illuminance","device.illuminanceX", width: 2, height: 2, inactiveLabel: false) {
            state "luminosity", label:'\n ${currentValue}', icon:"st.Weather.weather14"
        }
        valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false) {
            state "humidity", label:' ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }
        standardTile("motion", "device.motion", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'Request update', action:"configure"
		}
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state("detected", label:'TAMPER', backgroundColor:"#e86d13")
			state("clear", label:'', backgroundColor:"#FFFFFF")
		}
        standardTile("display", "device.dashboardDisplay", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "default", label:'${currentValue}', defaultState: true
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
        }
        
        main "display"
        details(["summary", "temperature", "humidity", "illuminance", "battery", "configure", "tamper"])
    }
}

private Double[] percentTable() {
    return [ 0.0, 22.5, 24.5, 32.5, 40.5, 55.0, 64.5, 74.5, 85.5, 89.0, 97.5, 100.0 ]
}

private Double[] luxTable() {
    return [ 0.0, 1.0, 2.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0 ]
}

def uninstalled() {
	log.trace "Uninstalled called"
}

def installed() {
	log.trace "Installed called settings: $settings"
	// Device-Watch simply pings if no device events received for 482min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
	try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def updated() {
	log.trace "Update called settings: $settings"
	// Device-Watch simply pings if no device events received for 482min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
	try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def parse(String description) {
	//log.trace "$description"
    
	def result = null
	if (description.startsWith("Err 106")) {
		state.security = false // This is a secure communications device we are working with, it's failed
		result = createEvent( name: "secureInclusion", value: "failed", eventType: "ALERT", descriptionText: "This sensor failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.")
	} else if (description.startsWith("Err")) {
	    result = createEvent(descriptionText:description)
	} else {
		def cmd = zwave.parse(description, [0x71: 3, 0x31: 5, 0x85: 2, 0x86: 1, 0x84: 2, 0x70: 1, 0x86: 1, 0x98: 1]) // Device support sensorMultiLevel(0x31) is v7 but ST only supports v5, Notification(0x71) is v4 but ST only supports v3, verion(0x86) is v2 but ST only supports v1
		if (cmd) {
			result = zwaveEvent(cmd)
		} else {
			result = createEvent(value: description, descriptionText: description, isStateChange: false)
		}
	}

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Monoprice 4 in 1 Enhanced Device Handler"]) // Save DH Name for parent app

    log.debug "Parse returned ${result}"
	return result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    //log.debug "Security cmd: $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x71: 3, 0x31: 5, 0x85: 2, 0x86: 1, 0x84: 2, 0x70: 1, 0x86: 1])
	//log.trace "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
        state.security = true // This is a secure communications device we are working with
		zwaveEvent(encapsulatedCommand)
	}
}

def sensorValueEvent(def value) {
    if (!displaySensor || displaySensor == "Motion") { // Update summary display sensor
        sendEvent(name: "dashboardDisplay", value: value ? "active" : "inactive")
    }

    if (value) {
		createEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
	} else {
		createEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion has stopped")
	}
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.sensorbinaryv1.SensorBinaryReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.sensorValue)
}

def zwaveEvent(physicalgraph.zwave.commands.sensoralarmv1.SensorAlarmReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.sensorState)
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd)
{
	log.trace "NotificationReport: $cmd"
	def result = []
	if (cmd.notificationType == 0x07) {
        if ((cmd.event == 0x08) || ((cmd.event == 0x00) && (cmd.eventParameter[0] == 0x08))) { // BasicSet and Notification both come in, whichever is faster, bug in documentation, with notification parameter doesn't always contain 0x08
			result << sensorValueEvent(cmd.v1AlarmLevel)
		} else if ((cmd.event == 0x03)) { // Bug, eventParameter is supposed to be 0x03 but it doesn't send it
			result << createEvent(name: "tamper", value: "detected", descriptionText: "$device.displayName covering was removed", isStateChange: true)
		} else if ((cmd.event == 0x00) && (cmd.eventParameter[0] == 0x03)) {
			result << createEvent(name: "tamper", value: "clear", descriptionText: "$device.displayName covering was closed", isStateChange: true)
		}
	} else {
        log.warn "Unknown notification: $cmd"
		result << createEvent(name: "UnknownNotification", descriptionText: cmd.toString(), displayed: true)
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
	log.debug "Device woke up"
    
	def event = createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)
    def cmds = []
    if(!state.MSR) { // Until we have MSR we don't know what product we have, so try both
        log.debug "Getting MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet()
    }
    
    /*log.debug "Discovering parameters from 1 to 5 from device"
    (1..10).each { parameter ->
    	cmds << zwave.configurationV1.configurationGet(parameterNumber: parameter)
    }*/
    
    switch (state.MSR) {
        default:
        	log.trace "Found Z-Wave device with MSR $state.MSR"
        	break
    }

    if (!state.wakeupSet) { // Configure polling
        if (manualPollInterval) { // Manual poll period set
            log.info "Setting manual poll interval to $manualPollInterval seconds"
            cmds << zwave.wakeUpV2.wakeUpIntervalCapabilitiesGet() // Get Wake up interval capabilities
            cmds << zwave.wakeUpV2.wakeUpIntervalSet(seconds:manualPollInterval, nodeid:zwaveHubNodeId) // Set the wake up interval
            cmds << zwave.wakeUpV2.wakeUpIntervalGet() // Check our current wake up interval
        } else {
            log.info "No manual poll, setting default wake up"
            cmds << zwave.wakeUpV2.wakeUpIntervalSet(seconds: 3600, nodeid:zwaveHubNodeId) // Default: Set the wake up interval to every 3600 seconds
            cmds << zwave.wakeUpV2.wakeUpIntervalGet() // Check our current wake up interval
        }
        
        state.wakeupSet = true // We're done, don't update again unless requested
    }

    if (!state.configSet) { // Set configuration
        // Set temperature reporting
        if (getTemperatureScale() == "F") {
            log.debug "Setting temperature scale to F"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [1]) // Set to F
        } else {
            log.debug "Setting temperature scale to C"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0]) // Set to C
        }
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 1)

        if (tempSensitivity && (tempSensitivity >= 0.1 && tempSensitivity <= 5.0)) {
            log.info "Updating temperature reporting threshold to $tempSensitivity°"
            Integer tempSetting = (tempSensitivity * 10) as Integer // Temp reporting threshold is between 1 and 50 with each 1 representing 0.1°
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, configurationValue: [tempSetting])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        } else {
            log.info "Settings temperature reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        }

        if (humiditySensitivity && (humiditySensitivity >= 1 && humiditySensitivity <= 50)) {
            log.info "Updating humidity reporting threshold to $humiditySensitivity%"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, configurationValue: [humiditySensitivity])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        } else {
            log.info "Settings humidity reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        }

        if (luxSensitivity && (luxSensitivity >= 5 && luxSensitivity <= 50)) { // Minimum is 5 even though documentation says 1
            log.info "Updating light reporting threshold to $luxSensitivity%"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, configurationValue: [luxSensitivity])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        } else {
            log.info "Settings light reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        }

        if (noMotionTimeout && (noMotionTimeout >= 1 && noMotionTimeout <= 255)) {
            log.info "Updating Inactivity timeout to $noMotionTimeout minutes"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 5, configurationValue: [noMotionTimeout]) // Set inactivity timeout in minutes
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 5) // Confirm inactivity timeout
        } else {
            log.info "Settings inactivity timeout to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 5, defaultValue: true) // Set inactivity timeout in minutes
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 5) // Confirm inactivity timeout
        }

        if (pirSensitivity && (pirSensitivity >= 1 && pirSensitivity <= 7)) {
            log.info "Updating PIR sensitivity to $pirSensitivity"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 6, configurationValue: [pirSensitivity]) // Set PIR sensitivity
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 6) // Confirm PIR sensitivity
        } else {
            log.info "Setting PIR sensitivity to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 6, defaultValue: true) // Set PIR sensitivity
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 6) // Confirm PIR sensitivity
        }
        
        if (ledConfig) {
            def ledMode = 3 // Default is flashing
            switch (ledConfig) {
                case "1":
                	log.info "Setting LED mode to Off"
                	ledMode = 1
                    break
                    
                case "2":
                	log.info "Setting LED mode to Breathing"
                	ledMode = 2
                    break
                    
                case "3":
                	log.info "Setting LED mode to Quick Flash"
                	ledMode = 3
                    break
                    
                default:
                	log.warn "Invalid LED mode: $ledConfig, settings to default Breathing"
                    break
            }
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 7, configurationValue: [ledMode])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 7)
        } else {
            log.info "Setting LED Mode to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 7, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 7)
        }

		cmds << zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId) // Set group association to identifier 1

        state.configSet = true // We're done, dont' update again unless requested
    }

    // Each time the device is woken up (pin) force a sensor update
    log.info "Requesting sensors and battery update"
    cmds << zwave.sensorBinaryV1.sensorBinaryGet() // Motion Sensor
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x01) // current temperature
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x03) // current light
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x05) // current humidity
    cmds << zwave.batteryV1.batteryGet() // Battery level
    
	cmds << zwave.wakeUpV2.wakeUpNoMoreInformation() // All DONE
    
    //log.trace "Sending: $cmds"
    
    [event, getResponses(cmds)]
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "BatteryReport: $cmd"
    
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbat = now()

    return [createEvent(map)]
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv5.SensorMultilevelReport cmd) // Take the highest level 5 (for Z-Wave Plus Motion) which is backwards compatible with level 4 (for Z-Wave motion sensor)
{
	log.trace "SensorMultiLevelReport: $cmd"
    
	def map = [ displayed: true, value: cmd.scaledSensorValue.toString(), isStateChange: true ] // Report each temperature report even if the value hasn't changed
	switch (cmd.sensorType) {
		case 1:
			map.name = "temperature"
			def cmdScale = cmd.scale == 1 ? "F" : "C"
            map.value = ((convertTemperatureIfNeeded(cmd.scaledSensorValue, cmdScale, cmd.precision) as Double) + (tempOffset ?: 0)).round(1)
            map.unit = getTemperatureScale()
            map.descriptionText = "${device.displayName} temperature is ${map.value} °${map.unit}"
            if (displaySensor == "Temperature") { // Update summary display sensor
                sendEvent(name: "dashboardDisplay", value: map.value + " °" + map.unit)
            }
			break;
            
		case 3:
        	map.name = "illuminance"
            if (luxMetric == "lux") {
                Double percValue = cmd.scaledSensorValue as Double
                map.value = interpolate(percentTable(), luxTable(), percValue).round(0) as Integer // no decimals, keep it clean
                map.unit = "lux"
            } else {
                map.value = (cmd.scaledSensorValue as Double).round(0) as Integer // no decimals, keep it clean
                map.unit = "%"
            }
        	map.descriptionText = "${device.displayName} light is ${map.value}${map.unit}"
        	sendEvent([name: "illuminanceX", value: map.value + " " + map.unit])
            if (displaySensor == "Light") { // Update summary display sensor
                sendEvent(name: "dashboardDisplay", value: map.value + " " + map.unit)
            }
			break;
            
		case 5:
			map.name = "humidity"
			map.value = ((cmd.scaledSensorValue as Double) + (humidityOffset ?: 0)).round(0) as Integer // no decimals, keep it clean
			map.unit = "%"
            map.descriptionText = "${device.displayName} humidity is ${map.value}${map.unit}"
            if (displaySensor == "Humidity") { // Update summary display sensor
                sendEvent(name: "dashboardDisplay", value: map.value + " " + map.unit)
            }
			break;
            
		default:
        	log.warn "Unknown Sensor report sensor type: $cmd.sensorType"
            map.name = "unknown $cmd.sensorType"
			break;
	}
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unhandled command: $cmd"
	createEvent(descriptionText: "$device.displayName: $cmd", displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalReport cmd) {
    log.trace "WakeUpIntervalReport $cmd"
}

// WakeUpIntervalCapabilitiesReport(defaultWakeUpIntervalSeconds: 3600, maximumWakeUpIntervalSeconds: 604800, minimumWakeUpIntervalSeconds: 600, wakeUpIntervalStepSeconds: 600)
def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalCapabilitiesReport cmd) {
    log.trace "WakeUpIntervalCapabilitiesReport $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    def msg = null
    switch (cmd.parameterNumber) {
        case 1:
        	msg = "Temperature unit: °${cmd.configurationValue[0] ? "F" : "C"}"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 2:
        	Double tempRT = ((cmd.configurationValue[0] as Double)/10).round(1)
        	msg = "Temperature reporting threshold: ${tempRT}°"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 3:
        	msg = "Humidity reporting threshold: ${cmd.configurationValue[0]}%"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 4:
        	msg = "Light reporting threshold: ${cmd.configurationValue[0]}%"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 5:
        	msg = "Inactivity timeout: ${cmd.configurationValue[0]} minutes"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 6:
        	msg = "PIR Sensitivity: ${cmd.configurationValue[0]}"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break

        case 7:
        	switch (cmd.configurationValue[0]) {
                case 1:
	        		msg = "LED Mode: Off"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
    	            break
                
                case 2:
        			msg = "LED Mode: Temperature Breathing/Motion Flashing"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break
                    
                case 3:
                	msg = "LED Mode: Quick Flash"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break

                default:
                    log.warn "Invalid LED Mode: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        default:
            log.warn "Unknown parameter"
            break
    }
    
    log.debug msg
    result
}

private getResponses(commands, delay=1200) {
    if (state.security) {
        response(delayBetween(commands.collect{ zwave.securityV1.securityMessageEncapsulation().encapsulate(it).format() }, delay))
    } else {
        response(delayBetween(commands.collect{ it.format() }, delay))
    }
}

private getResponse(command) {
    if (state.security) {
        response(zwave.securityV1.securityMessageEncapsulation().encapsulate(command).format())
    } else {
        response(command.format())
    }
}

private secure(physicalgraph.zwave.Command cmd) {
	if (state.security) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private secureSequence(commands, delay=200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

def configure() {
    // Force a refresh
    log.debug "Requested a refresh of sensors and settings at next wakeup"
    
    if (tempOffset) {
        log.trace "Temperature offset set to $tempOffset"
    }
    
    if (humidityOffset) {
        log.trace "Humidity offset set to $humidityOffset"
    }
        
    // Sanity check for polling interval
    if (manualPollInterval && ((manualPollInterval < 600) || (manualPollInterval > 604800) || (manualPollInterval % 600 != 0))) { // Range is 600 - 604800 with an interval of 200 seconds
    	log.error "Invalid Manual Poll Interval $manualPollInterval! It must be between 600 and 604800 and must be in interval of 600 seconds, NOT using Manual Polling"
    }
    
    if (ledConfig) {
        switch (ledConfig) {
            case "1":
            case "2":
            case "3":
                break // All good

            default:
                log.warn "Invalid LED mode: $ledConfig, setting LED mode to default Breathing"
                break
        }
    }

    if (tempSensitivity && (tempSensitivity < 0.1 || tempSensitivity > 5.0)) {
    	log.error "Invalid temperature reporting threshold $tempSensitivity! It must be between 0.1 and 5.0, NOT updating temperature threshold"
    }
    
    if (luxSensitivity && (luxSensitivity < 5 || luxSensitivity > 50)) { // Minimum is 5 even though documentation says 1
    	log.error "Invalid light reporting threshold $luxSensitivity! It must be between 5 and 50, NOT updating light threshold"
    }
    
    if (humiditySensitivity && (humiditySensitivity < 1 || humiditySensitivity > 50)) {
    	log.error "Invalid humidity reporting threshold $humiditySensitivity! It must be between 5 and 50, NOT updating humidity threshold"
    }
    
    if (noMotionTimeout && (noMotionTimeout < 1 || noMotionTimeout > 255)) {
    	log.error "Invalid Inactivity timeout $noMotionTimeout! It must be between 1 and 255, NOT updating inactivity timeout"
    }
    
    if (pirSensitivity && (pirSensitivity < 1 || pirSensitivity > 7)) {
    	log.error "Invalid PIR Sensitivity $pirSensitivity! It must be between 1 and 7, NOT updating PIR sensitivity"
    }
    
    switch(displaySensor) {
        case "Temperature":
        	sendEvent(name: "dashboardDisplay", value: device.currentValue("temperature") + " °" + getTemperatureScale())
            break
        
        case "Humidity":
        	sendEvent(name: "dashboardDisplay", value: device.currentValue("humidity") + " %")
        	break
            
        case "Light":
        	sendEvent(name: "dashboardDisplay", value: device.currentValue("illuminanceX"))
        	break
            
        case "Motion":
        default:
        	sendEvent(name: "dashboardDisplay", value: device.currentValue("motion"))
        	break
    }

    state.configSet = false // We should set the inactivity timer
    state.wakeupSet = false // We should set the wake up interval
    
    // Configure is called at inclusion so we have a SMALL window to execute some commands here, won't make any differnce when called manually
    def cmds = []

    cmds += secureSequence([
        zwave.manufacturerSpecificV2.manufacturerSpecificGet(),
        zwave.batteryV1.batteryGet(),
        zwave.sensorBinaryV1.sensorBinaryGet(), // Motion Sensor
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x01), // current temperature
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x03), // current light
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x05), // current humidity
    ], 500) // Small delay works since typically at inclusion the sensor is near the hub for the NIF command so there's no routing involved here

    // Don't do a no more wakeup here as the hub ends up queueing it becase it's a passive device and it interfers with the wakup command due to a delayed retry from the hub, the device will timeout by itself in 10 seconds
    //cmds << "delay 8000"
    //cmds << secure(zwave.wakeUpV2.wakeUpNoMoreInformation()) // We're done here
    
    return cmds
}

private Double interpolate(Double[] x, Double[] y, Double xi) {

    if (x.size() != y.size()) {
        throw new IllegalArgumentException("X and Y must be the same length");
    }
    if (x.size() == 1) {
        throw new IllegalArgumentException("X must contain more than one value");
    }
    Double[] dx = new Double[x.size() - 1];
    Double[] dy = new Double[x.size() - 1];
    Double[] slope = new Double[x.size() - 1];
    Double[] intercept = new Double[x.size() - 1];

    // Calculate the line equation (i.e. slope and intercept) between each point
    for (int i = 0; i < x.size() - 1; i++) {
        dx[i] = x[i + 1] - x[i];
        if (dx[i] == 0) {
            throw new IllegalArgumentException("X must be montotonic. A duplicate x-value was found: ${x[i]}");
        }
        if (dx[i] < 0) {
            throw new IllegalArgumentException("X must be sorted");
        }
        dy[i] = y[i + 1] - y[i];
        slope[i] = dy[i] / dx[i];
        intercept[i] = y[i] - x[i] * slope[i];
    }

    // Interpolate the value
    Double yi;
    int loc = Collections.binarySearch(x as List, xi);
    if (loc < -1) {
        loc = -loc - 2;
        yi = slope[loc] * xi + intercept[loc];
    }
    else {
        yi = y[loc];
    }

    return yi;
}

// THIS IS THE END OF THE FILE